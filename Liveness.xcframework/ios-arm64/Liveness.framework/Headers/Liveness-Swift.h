#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef LIVENESS_SWIFT_H
#define LIVENESS_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="Liveness",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
/// <code>LivenessAction</code>: An enumeration that defines specific actions related to liveness detection within an iOS application using face recognition technology. Each case of this enumeration represents a different physical action that a user might be required to perform in front of the camera to verify their presence and identity. This enum is integral to the functioning of systems that require enhanced security measures through biometric verification methods.
/// Key Actions:
/// <ul>
///   <li>
///     <code>smile</code>: Detects the user’s smile, commonly used to verify that the user is actively and willingly participating in the liveness detection process.
///   </li>
///   <li>
///     <code>turnLeft</code> and <code>turnRight</code>: Involves the user turning their head in specific directions to confirm the presence of a live person rather than a static image.
///   </li>
///   <li>
///     <code>tiltLeft</code> and <code>tiltRight</code>: Similar to turning, tilting involves subtle movements of the head to sides which helps in a more thorough analysis of the depth and features of the face.
///   </li>
///   <li>
///     <code>blink</code>: Requires the user to blink, a natural and spontaneous action that is difficult to replicate using photographs or other static means.
///   </li>
///   <li>
///     <code>openMouth</code>: Another dynamic facial movement that ensures the liveness of the subject in front of the camera.
///   </li>
///   <li>
///     <code>sayWord</code>: Involves voice recognition along with face movement when saying a specific word, adding another layer of security.
///   </li>
/// </ul>
/// Example Usage:
/// <ul>
///   <li>
///     In financial apps, <code>RBKLivenessAction</code> can be used during critical transactions to ensure that the person conducting the transaction is the rightful owner of the account.
///   </li>
///   <li>
///     In secure entry systems, actions like turning the head or blinking might be required for entry to ensure that the system is interacting with a live person.
///   </li>
/// </ul>
/// This enumeration is typically used in conjunction with camera and facial recognition technologies to create robust, secure, and interactive user authentication systems.
typedef SWIFT_ENUM(NSInteger, LivenessAction, open) {
/// Action representing a smile detection.
  LivenessActionSmile = 0,
/// Action representing turning the head left.
  LivenessActionTurnLeft = 1,
/// Action representing turning the head right.
  LivenessActionTurnRight = 2,
/// Action representing tilting the head left.
  LivenessActionTiltLeft = 3,
/// Action representing tilting the head right.
  LivenessActionTiltRight = 4,
/// Action representing blinking detection.
  LivenessActionBlink = 5,
/// Action representing opening the mouth.
  LivenessActionOpenMouth = 6,
/// Action representing saying a word.
  LivenessActionSayWord = 7,
  LivenessActionAdditional = 8,
};

/// <code>LivenessAlert</code>
/// An enumeration defining specific alert conditions within liveness detection processes in iOS applications.
/// Cases:
/// <ul>
///   <li>
///     <code>faceNotFound</code>: No face is detected. Used to prompt the user to align themselves correctly in the camera view.
///   </li>
///   <li>
///     <code>singleFace</code>: More than one face is detected. Ensures that only the authorized user’s face is in view for liveness detection.
///   </li>
///   <li>
///     <code>straightHeadOpenEyes</code>: Instructs the user to keep their head straight with eyes open, ensuring clear facial feature visibility.
///   </li>
///   <li>
///     <code>headOutOfBounds</code>: The user’s head moves outside the camera’s designated focus area. Prompts repositioning for optimal detection.
///   </li>
/// </ul>
/// Example Usage:
/// <ul>
///   <li>
///     Secure access systems use these alerts to ensure that users adjust their position or facial expressions to meet entry requirements.
///   </li>
///   <li>
///     Online examination systems use <code>straightHeadOpenEyes</code> to maintain the visibility of the candidate’s face, upholding exam integrity.
///   </li>
/// </ul>
/// Implementation:
/// Implementing <code>LivenessAlert</code> in liveness detection systems enhances user interaction by providing clear, actionable feedback. This helps users correct their positioning or actions, thus improving the overall effectiveness and security of the authentication process.
typedef SWIFT_ENUM(NSInteger, LivenessAlert, open) {
/// <ul>
///   <li>
///     <code>faceNotFound</code>: No face is detected. Used to prompt the user to align themselves correctly in the camera view.
///   </li>
/// </ul>
  LivenessAlertFaceNotFound = 0,
/// <ul>
///   <li>
///     <code>singleFace</code>: More than one face is detected. Ensures that only the authorized user’s face is in view for liveness detection.
///   </li>
/// </ul>
  LivenessAlertSingleFace = 1,
/// <ul>
///   <li>
///     <code>straightHeadOpenEyes</code>: Instructs the user to keep their head straight with eyes open, ensuring clear facial feature visibility.
///   </li>
/// </ul>
  LivenessAlertStraightHeadOpenEyes = 2,
/// <ul>
///   <li>
///     <code>headOutOfBounds</code>: The user’s head moves outside the camera’s designated focus area. Prompts repositioning for optimal detection.
///   </li>
/// </ul>
  LivenessAlertHeadOutOfBounds = 3,
};

@class NSString;

/// <code>LivenessDataSource</code>
/// A protocol in iOS development that defines the interface for supplying textual information related to various stages and alerts within a liveness detection system. This protocol plays a crucial role in localizing and customizing the user interface feedback during liveness detection processes, allowing dynamic content changes based on the specific action or alert encountered.
/// Responsibilities:
/// <ul>
///   <li>
///     Provides text that describes the current liveness alert, enhancing user understanding and interaction during the detection process.
///   </li>
///   <li>
///     Offers descriptive text for each liveness action to guide the user through the required actions during the liveness check.
///   </li>
///   <li>
///     Supplies detailed descriptions for each action to assist in clarifying what the user is expected to do.
///   </li>
///   <li>
///     Returns custom text upon successful completion of an action, offering positive feedback and instructions for subsequent steps.
///   </li>
/// </ul>
/// Example Usage:
/// <ul>
///   <li>
///     In an application with multilingual support, implementing this protocol can dynamically provide text in the user’s preferred language, ensuring that the liveness detection process is accessible and understandable to all users.
///   </li>
///   <li>
///     In user experience-focused applications, the protocol can be used to provide detailed, context-specific guidance and feedback that enhances user engagement and compliance during security checks.
///   </li>
/// </ul>
/// Implementation:
/// <ul>
///   <li>
///     <code>liveness(textForAlert:)</code>: Method to return a string representing the message for specific alerts like face not found or multiple faces detected.
///   </li>
///   <li>
///     to use the default implementation, you must call the <code>defaultLiveness(textForAlert:)</code> in the closure of this method
///   </li>
///   <li>
///     <code>liveness(textForAction:)</code>: Method that provides instructional text for a given action, such as “Turn your head to the left”.
///   </li>
///   <li>
///     to use the default implementation, you must call the <code>defaultLiveness(textForAction:)</code> in the closure of this method
///   </li>
///   <li>
///     <code>liveness(descriptionTextForAction:)</code>: Offers a more detailed explanation of the action, helping to ensure that the user is clear on what is expected.
///   </li>
///   <li>
///     to use the default implementation, you must call the <code>defaultLiveness(descriptionTextForAction:)</code> in the closure of this method
///   </li>
///   <li>
///     <code>liveness(textForPassedAction:)</code>: Delivers feedback once an action is successfully completed, such as “Action successfully completed”.
///   </li>
///   <li>
///     to use the default implementation, you must call the <code>defaultLiveness(textForPassedAction:)</code> in the closure of this method
///   </li>
///   <li>
///     <code>Attention!</code> To use default values, you have to enable language support in your application
///   </li>
/// </ul>
/// This protocol is essential for making the liveness detection features in applications not only functional but also user-friendly and adaptable to various user environments and requirements.
SWIFT_PROTOCOL("_TtP8Liveness18LivenessDataSource_")
@protocol LivenessDataSource
/// Returns the text to be displayed for a specific liveness alert.
/// \param alert The type of liveness alert.
///
///
/// returns:
/// The text to be displayed for the alert.
- (NSString * _Nullable)livenessWithTextForAlert:(enum LivenessAlert)alert SWIFT_WARN_UNUSED_RESULT;
/// Returns the text to be displayed for a specific liveness action.
/// \param action The type of liveness action.
///
///
/// returns:
/// The text to be displayed for the action.
- (NSString * _Nullable)livenessWithTextForAction:(enum LivenessAction)action SWIFT_WARN_UNUSED_RESULT;
/// Returns the description text for a specific liveness action.
/// \param action The type of liveness action.
///
///
/// returns:
/// The description text for the action.
- (NSString * _Nullable)livenessWithDescriptionTextForAction:(enum LivenessAction)action SWIFT_WARN_UNUSED_RESULT;
/// Returns the text to be displayed when a specific liveness action is passed successfully.
/// \param action The type of liveness action.
///
///
/// returns:
/// The text to be displayed for the passed action.
- (NSString * _Nullable)livenessWithTextForPassedAction:(enum LivenessAction)action SWIFT_WARN_UNUSED_RESULT;
@end

@class UIImage;
@class LivenessResult;
@class NSURL;

/// <code>LivenessDelegate</code>
/// A protocol in iOS development that defines the delegate methods used by <code>LivenessCameraController</code> to communicate liveness detection results back to the implementing class. This delegate protocol is essential for handling real-time feedback from the liveness detection system, including face detection, action progression, and video recording outcomes.
/// Responsibilities:
/// <ul>
///   <li>
///     Responds to successful face detection events by receiving an image of the detected face.
///   </li>
///   <li>
///     Receives notifications before an action is attempted, allowing the delegate to prepare or adjust the UI accordingly.
///   </li>
///   <li>
///     Handles the completion of actions, providing an opportunity to process results and determine the next steps.
///   </li>
///   <li>
///     Manages the handling of video recording outcomes, useful in scenarios where the liveness detection involves recording clips.
///   </li>
///   <li>
///     Acknowledges the successful completion of all liveness detection actions, signaling that the user has passed all required checks.
///   </li>
/// </ul>
/// Example Usage:
/// <ul>
///   <li>
///     In a secure authentication flow, the delegate methods can be used to update the UI with instructions or feedback based on the user’s interaction with the liveness detection system.
///   </li>
///   <li>
///     In applications requiring enhanced security, such as banking apps, the delegate can trigger additional security measures or proceed with transaction authorization upon successful completion of liveness checks.
///   </li>
/// </ul>
/// Implementation:
/// <ul>
///   <li>
///     The <code>liveness(didCaptureFaceIn:)</code> method can be implemented to store or analyze the captured face image.
///   </li>
///   <li>
///     <code>liveness(willPassAction:)</code> and <code>liveness(didPassActionWith:)</code> methods manage the flow of actions during liveness detection, ensuring that each step is logged or audited.
///   </li>
///   <li>
///     <code>liveness(didRecordVideoTo:)</code> provides a handle to the recorded video, potentially for review or archival.
///   </li>
///   <li>
///     <code>livenessDidSucceed()</code> confirms that all prescribed actions have been successfully completed, often used to unlock the next phase of an authentication or verification process.
///   </li>
/// </ul>
/// This protocol allows for tight integration between the camera controller and the broader application, ensuring that all aspects of liveness detection are appropriately managed and reflected in the user interface or system state.
SWIFT_PROTOCOL("_TtP8Liveness16LivenessDelegate_")
@protocol LivenessDelegate
/// Called when a face is detected on the camera
/// \param image UIImage of the captured face
///
- (void)livenessWithDidCaptureFaceIn:(UIImage * _Nonnull)image;
/// Called after the current action is displayed
/// \param action Current action
///
- (void)livenessWithWillPassAction:(enum LivenessAction)action;
/// Called after the current action is completed
/// \param action Completed action
///
- (void)livenessWithDidPassActionWith:(LivenessResult * _Nonnull)result;
- (void)livenessWithDidRecordVideoTo:(NSURL * _Nonnull)url;
/// Called after the successful completion of all actions
- (void)livenessDidSucceed;
@end


SWIFT_CLASS("_TtC8Liveness14LivenessResult")
@interface LivenessResult : NSObject
@property (nonatomic, readonly) enum LivenessAction action;
@property (nonatomic, readonly, strong) UIImage * _Nullable image;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class UIColor;
@class NSCoder;
@class NSBundle;

/// <code>LivenessViewController</code>: A UIViewController subclass that orchestrates the user interface and interaction flows for liveness detection in an iOS application. This class integrates various components including a camera controller, UI elements like labels and activity indicators, and business logic through an associated interactor. It manages the presentation of camera feeds, user prompts (e.g., “Turn your head to the left”), and feedback based on liveness detection results.
/// Example Usage:
/// <ul>
///   <li>
///     In a banking app, <code>LivenessViewController</code> could be used during a security check to ensure that the account holder is a real person and is present during the transaction.
///   </li>
///   <li>
///     For access control in secure facilities, this controller can manage the process of capturing live facial features to compare with stored biometric data, ensuring that only authorized individuals gain entry.
///   </li>
/// </ul>
/// Key Components:
/// <ul>
///   <li>
///     <code>cameraController</code>: Manages camera setup, video capture, and real-time face detection.
///   </li>
///   <li>
///     <code>titleLabel</code>, <code>descriptionLabel</code>: Display instructions and feedback to the user, guiding them through necessary actions or providing status updates.
///   </li>
///   <li>
///     <code>focusView</code>, <code>arrowsView</code>: Visual cues to direct the user’s gaze or head movement, enhancing the accuracy of liveness detection.
///   </li>
///   <li>
///     <code>activityIndicatorView</code>: Indicates processing or loading states, improving the user interface responsiveness.
///   </li>
/// </ul>
/// This controller is designed to be embedded within a larger authentication or security workflow, coordinating with other components of the application to provide a seamless and secure user experience.
SWIFT_CLASS("_TtC8Liveness22LivenessViewController")
@interface LivenessViewController : UIViewController
/// The delegate for liveness events.
@property (nonatomic, weak) id <LivenessDelegate> _Nullable delegate;
/// The data source for liveness content.
@property (nonatomic, weak) id <LivenessDataSource> _Nullable dataSource;
/// Indicates whether to set the maximum brightness.
@property (nonatomic) BOOL shouldSetMaxBrightness;
/// The color of the title label.
@property (nonatomic, strong) UIColor * _Nonnull titleColor;
/// The text displayed during loading states.
@property (nonatomic, copy) NSString * _Nonnull loadingText;
/// Initializes the liveness view controller.
/// \param isRecordingEnabled Indicates whether recording is enabled.
///
- (nonnull instancetype)initWithIsRecordingEnabled:(BOOL)isRecordingEnabled OBJC_DESIGNATED_INITIALIZER;
- (void)viewDidLoad;
- (void)viewDidLayoutSubviews;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewWillDisappear:(BOOL)animated;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end




@class UIFont;

@interface LivenessViewController (SWIFT_EXTENSION(Liveness))
/// The font for the title label.
@property (nonatomic, strong) UIFont * _Nonnull titleFont;
/// The font for the description label.
@property (nonatomic, strong) UIFont * _Nonnull descriptionFont;
/// The color for the description label text.
@property (nonatomic, strong) UIColor * _Nonnull descriptionColor;
/// Indicates whether the activity indicator view is currently loading.
@property (nonatomic) BOOL isActivityIndicatorLoading;
@end





#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
